{"./":{"url":"./","title":"README","keywords":"","body":"Go!!!内容包括:Go!!! 导航:课件大全 内容包括: golang 基础部分 go 实战 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 09:44:25 "},"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第3章_错误处理和资源管理/":{"url":"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第3章_错误处理和资源管理/","title":"第3章_错误处理和资源管理","keywords":"","body":"3-1 defer调用.mp43-2 错误处理概念.mp43-3 服务器统一出错处理浏览器需放大.mp43-4 服务器统一出错处理.mp43-1 defer调用.mp4 func writeFile(filename string){ file,err:=os.Create(filename) if err != nil { panic(err) } defer file.Close() writer:= bufio.NewWriter(file) defer writer.Flush() for i := 0; i 等我代码写完了,我就忘记这个了 所以我就进就加一个这个 package main import ( \"bufio\" \"fmt\" \"os\" ) func tryDefer() { defer fmt.Println(2) defer fmt.Println(1) fmt.Println(3) fmt.Println(4) } func writeFile(filename string) { file, err := os.Create(filename) if err != nil { panic(err) } defer file.Close() writer := bufio.NewWriter(file) defer writer.Flush() for i := 0; i 3-2 错误处理概念.mp4 package main import ( \"bufio\" \"fmt\" \"os\" ) func tryDefer() { defer fmt.Println(2) defer fmt.Println(1) fmt.Println(3) fmt.Println(4) } func writeFile(filename string) { file, err := os.Create(filename) if err != nil { panic(err) } defer file.Close() writer := bufio.NewWriter(file) defer writer.Flush() for i := 0; i 如果文件存在就报错 可以处理一下 func writeFile2(filename string) { file, err := os.OpenFile( filename, os.O_EXCL|os.O_CREATE, 0666) if err != nil { fmt.Println(\"flie already exist!!!\") return } defer file.Close() writer := bufio.NewWriter(file) defer writer.Flush() for i := 0; i 真正的处理错误 func writeFile2(filename string) { file, err := os.OpenFile( filename, os.O_EXCL|os.O_CREATE, 0666) if err != nil { if pathError, ok := err.(*os.PathError); !ok { // 真的 不知道是森什么错了 // 那就挂掉程序吧 panic(err) } else { fmt.Printf(\"%s, %s, %s\\n\", pathError.Op, pathError.Path, pathError.Err, ) } return } defer file.Close() writer := bufio.NewWriter(file) defer writer.Flush() for i := 0; i 3-3 服务器统一出错处理浏览器需放大.mp4 3-4 服务器统一出错处理.mp4 error vs panic 意料之中: 使用error . 如文件打不开 意料之外: 使用panic . 如数组越界 输入的参数类型是函数 输出的返回类型也是函数 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 09:44:25 "},"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第4章_测试与性能调优/":{"url":"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第4章_测试与性能调优/","title":"第4章_测试与性能调优","keywords":"","body":"4-1测试.mp4传统测试表格驱动测试4-2代码覆盖率和性能测试.mp44-3使用pprof进行性能调优.mp44-4测试http服务器（上）.mp44-5测试http服务器（下）.mp44-6生成文档和示例代码.mp44-1测试.mp4 传统测试vs表格驱动测试 传统测试 测试数据和测试逻辑混在一起 出错信息不明确 —旦一个数据出错测试全部结束 表格驱动测试 分离的测试数据和测试逻辑 明确的出错信息 可以部分失败 go语言的语法使得我们更易实践表格驱动测试 package main import \"testing\" func TestTriangle(t *testing.T){ tests := []struct{a,b,c int }{ {3,4,5}, {5,12,13}, {8,15,17}, {12,35,37}, {30000,40000,52000}, } for _,tt:=range tests{ if actual:= calcTriangle(tt.a,tt.b); actual !=tt.c{ t.Errorf(\"calcTriang %d %d got %d ; exceped\",tt.a,tt.b,tt.c) } } } === RUN TestTriangle add_test.go:16: calcTriang 30000 40000 got 52000 ; exceped --- FAIL: TestTriangle (0.00s) FAIL Process finished with the exit code 1 4-2代码覆盖率和性能测试.mp4 go test -coverprofile=c.out go test -coverprofile=c.out . go tool pprof cpu.out go tool pprof -cpuprofile cpu.out 4-3使用pprof进行性能调优.mp4 4-4测试http服务器（上）.mp4 4-5测试http服务器（下）.mp4 package main import ( \"errors\" \"fmt\" \"io/ioutil\" \"net/http\" \"net/http/httptest\" \"os\" \"strings\" \"testing\" ) func errPanic(writer http.ResponseWriter, request *http.Request) error { panic(123) } type testingUserError string func (e testingUserError) Error() string { return e.Message() } func (e testingUserError) Message() string { return string(e) } func errUserError(writer http.ResponseWriter, request *http.Request) error { return testingUserError(\"user error\") } func errNotFound(writer http.ResponseWriter, request *http.Request) error { return os.ErrNotExist } func errNoPermission(writer http.ResponseWriter, request *http.Request) error { return os.ErrPermission } func errUnknown(writer http.ResponseWriter, request *http.Request) error { return errors.New(\"unknown error\") } func noError(writer http.ResponseWriter, request *http.Request) error { fmt.Fprintln(writer, \"no error\") return nil } func TestErrWrapper(t *testing.T) { tests := []struct { h appHandler code int message string }{ {errPanic, 500, \"Internal Server Error\"}, {errUserError, 400, \"user error\"}, {errNotFound, 404, \"Not Found\"}, {errNoPermission, 403, \"Forbidden\"}, {errUnknown, 500, \"Internal Server Error\"}, {noError, 200, \"no error\"}, } for _, tt := range tests { f := errWrapper(tt.h) response := httptest.NewRecorder() request := httptest.NewRequest( http.MethodGet, \"http://localhost:8888/list/fib2.txt\", nil, ) f(response, request) b, _ := ioutil.ReadAll(response.Body) body := strings.Trim(string(b), \"\\n\") if response.Code != tt.code || body != tt.message { t.Errorf(\"expect (%d, %s)\"+ \"expect (%d, %s);\\\"\", tt.code, tt.message, response.Code, body, ) } } } /** === RUN TestErrWrapper time=\"2021-10-26T20:55:25+08:00\" level=info msg=\"Painic: 123\" --- PASS: TestErrWrapper (0.02s) PASS Process finished with the exit code 0 API server listening at: 127.0.0.1:50219 === RUN TestErrWrapper --- PASS: TestErrWrapper (0.00s) PASS Debugger finished with the exit code 0 API server listening at: 127.0.0.1:50243 === RUN TestErrWrapper --- PASS: TestErrWrapper (0.00s) PASS Debugger finished with the exit code 0 */ 函数是一等公民 func TestErrWrapperInServer(t *testing.T) { for _, tt := range tests { f := errWrapper(tt.h) server := httptest.NewServer( http.HandlerFunc(f)) resp, _ := http.Get(server.URL) b, _ := ioutil.ReadAll(resp.Body) body := strings.Trim(string(b), \"\\n\") if resp.StatusCode != tt.code || body != tt.message { t.Errorf(\"expect (%d, %s)\"+ \"expect (%d, %s);\\\"\", tt.code, tt.message, resp.StatusCode, body, ) } } } /** === RUN TestErrWrapperInServer --- PASS: TestErrWrapperInServer (0.00s) PASS Process finished with the exit code 0 */ 通过testing库里面的 http假的request 这种更像单元测试 通过启动http服务来进行测试 这种更加的全面 4-6生成文档和示例代码.mp4 godoc -http :6060 package queue import \"fmt\" func ExampleQueue_Pop() { q := Queue{1} q.Push(2) q.Push(3) fmt.Println(q.Pop()) fmt.Println(q.Pop()) fmt.Println(q.IsEmpty()) fmt.Println(q.Pop()) fmt.Println(q.IsEmpty()) // Output: // 1 // 2 // false // 3 // true } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 09:44:25 "},"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第5章_Goroutine/":{"url":"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第5章_Goroutine/","title":"第5章_Goroutine","keywords":"","body":"5-1 goroutine.mp45-2 go语言的调度器.mp4携程特点5-1 goroutine.mp4 package main import \"fmt\" func main() { //fmt.Printf(\"hellow from goroutine %d\") for i := 0; i 携程 Coroutine 轻量级\"线程\" 非抢占式 多任务处理,由携程主动交出控制权 package main import ( \"fmt\" \"time\" ) func main() { //fmt.Printf(\"hellow from goroutine %d\") var a [10]int for i := 0; i package main import ( \"fmt\" \"runtime\" \"time\" ) func main() { //fmt.Printf(\"hellow from goroutine %d\") var a [10]int for i := 0; i 不明觉厉,他们有什么区别??? 如果不传递i 会发生: package main import ( \"fmt\" \"runtime\" \"time\" ) func main() { //fmt.Printf(\"hellow from goroutine %d\") var a [10]int for i := 0; i go run .\\goroutine.go -race panic: runtime error: index out of range [10] with length 10 goroutine 15 [running]: main.main.func1() E:/Projects/GolandProjects/go-camp/mooc/code/learngo/goroutine/goroutine.go:16 +0x56 created by main.main E:/Projects/GolandProjects/go-camp/mooc/code/learngo/goroutine/goroutine.go:13 +0x57 panic: runtime error: index out of range [10] with length 10 goroutine 10 [running]: main.main.func1() E:/Projects/GolandProjects/go-camp/mooc/code/learngo/goroutine/goroutine.go:16 +0x56 created by main.main E:/Projects/GolandProjects/go-camp/mooc/code/learngo/goroutine/goroutine.go:13 +0x57 exit status 2 PS E:\\Projects\\GolandProjects\\go-camp\\mooc\\code\\learngo\\goroutine> */ 5-2 go语言的调度器.mp4 携程特点 轻量级的线程 非抢占式多任务处理,有携程主动交出控制权 编译器/解释器/虚拟机层面的多任务 多个携程可能在一个或者多个线程上运行 任何函数只需加上go就能送给调度器运行 不需要在定义时区分是否是异步函数 调度器在合适的点进行切换 使用-race来检测数据访问冲突 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 09:44:25 "},"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第6章_Channel/":{"url":"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第6章_Channel/","title":"第6章_Channel","keywords":"","body":"6-1 channel代码案例code1 基本chan收发code2 加上等待,避免主线程停止而导致其他chan都被干掉code3 worker提取出来code4 chan可以通过外部参数传递进来code5 格式化一下code6 并发从chan读取code7 chancode8 加上缓冲区(指定长度)code9 chan 不用同步收发了就code10 能够通过 err判断 chan是否 没消息了code11 chan的for in 遍历理论channelgo语言的创作者说6-2 使用Channel等待任务结束code01 顺序打印待修复code02 报错了code03 等待的也 开goroutinecode04 waitgroup方式来进行判断code05 函数是一等公民之再次改进6-3 使用Channel进行树的遍历code016-4 Selectcode1 非阻塞式的处理code02 死循环code03 改进code04 temp 改进中code05 sleep长一点就会出问题code06 吧收到的n,存下来排队code07 让程序 10秒钟后结束code08 超时的情况code09 定时的加入 每秒显示长度6-5 传统同步机制code0 init atomiccode01 加上锁的code 02 部分加锁 (匿名函数)协程Coroutine这可能是最容易理解的 Go Mutex 源码剖析6-6 并发模式（上）code00 initcode01 加上方向code 02 开两个 msgGencode03 加上参数code 04 让他们交替code 05 select 方式6-7 并发模式（下）code00 出现问题 goroutine循环变量的坑code01 解决方式self6-8 并发任务的控制code00 select 等待 (非阻塞等待)code01 timeout 支持设置等待时间(超时机制)code02 处理中断code03 优雅的退出这可能是最容易理解的 Go Mutex 源码剖析 6-1 channel 代码案例 code1 基本chan收发 package main import \"fmt\" func chanDemo() { //var c chan int // c == nil c := make(chan int) c 死锁了 发的数据没人收是会deadlock的 code2 加上等待,避免主线程停止而导致其他chan都被干掉 package main import ( \"fmt\" \"time\" ) func chanDemo() { //var c chan int // c == nil c := make(chan int) go func() { for { n:= go语言函数是一等公民 go语言中的channel 也是一等公民 code3 worker提取出来 package main import ( \"fmt\" \"time\" ) func worker(c chan int) { for { n := code4 chan可以通过外部参数传递进来 package main import ( \"fmt\" \"time\" ) func worker(id int,c chan int) { for { fmt.Println(id, 在打印 code5 格式化一下 package main import ( \"fmt\" \"time\" ) func worker(id int, c chan int) { for { fmt.Printf(\"%d,%c\\n\", id, goroutine 调度之后,先发的不一定会先收到 code6 并发从chan读取 package main import ( \"fmt\" \"time\" ) func createWorker(id int) chan int { c := make(chan int) go func() { for { fmt.Printf(\"@%d---%c\\n\", id, // // 告诉外面用的人 , 我这个channel怎么用 这样就不能收数据了,只能发 属性 (send-only type) //n:= code7 chan package main import ( \"fmt\" \"time\" ) // // 告诉外面用的人 , 我这个channel怎么用 func createWorker(id int) chan 这样就是到4个 追加的时候才报错 code8 加上缓冲区(指定长度) func bufferedChannel() { // 加上缓冲区,大小为3 c := make(chan int,3) c code9 chan 不用同步收发了就 package main import ( \"fmt\" \"time\" ) func worker(id int,c chan int) { for { fmt.Printf(\"@%d---%c\\n\", id, 告诉接收方,何时发完了 code10 能够通过 err判断 chan是否 没消息了 package main import ( \"fmt\" \"time\" ) func worker(id int, c chan int) { for { n,ok := code11 chan的for in 遍历 func worker(id int, c chan int) { for n := range c { fmt.Printf(\"@%d---%d\\n\", id, n) } } // 这样也可以 理论channel channel buffered channel range 理论基础:Communication Sequential Process (CSP) go语言的创作者说 go语言的创作者说: Don't communicate by sharing memory; sharememory by communicating. 不要通过共享内存来通讯;通过通信来共享内存 6-2 使用Channel等待任务结束 通过通信来共享内存 code01 顺序打印待修复 目前是按照顺序打印的 package main import ( \"fmt\" \"time\" ) func doWork(id int, c chan int, done chan bool) { for n := range c { fmt.Printf(\"@%d---%d\\n\", id, n) // 通知外面 做完了( channel 是一等公民) done code02 报错了 package main import ( \"fmt\" \"time\" ) func doWork(id int, c chan int, done chan bool) { for n := range c { fmt.Printf(\"@%d---%d\\n\", id, n) // 通知外面 做完了( channel 是一等公民) done 大写字母那部分,发完了,没有来接收的,发会阻塞住 因为 channel 没有长度 code03 等待的也 开goroutine func doWork(id int, c chan int, done chan bool) { for n := range c { fmt.Printf(\"@%d---%d\\n\", id, n) // 通知外面 做完了( channel 是一等公民) go func() { done 这是因为我们需要等2次,如果我们只是等一次就不用的 code04 waitgroup方式来进行判断 package main import ( \"fmt\" \"sync\" //\"time\" ) func doWork( id int, c chan int, wg *sync.WaitGroup, ) { for n := range c { fmt.Printf(\"@%d---%d\\n\", id, n) // 通知外面 做完了( channel 是一等公民) wg.Done() } } type worker struct { in chan int wg *sync.WaitGroup } // 告诉外面用的人 , 我这个channel怎么用 func createWorker(id int, wg *sync.WaitGroup) worker { // 告诉外面用的人 , 我这个channel怎么用 // w := worker{ in: make(chan int), wg: wg, } go doWork(id, w.in, wg) return w } func chanDemo() { var wg sync.WaitGroup var workers [10]worker for i := 0; i code05 函数是一等公民之再次改进 package main import ( \"fmt\" \"sync\" //\"time\" ) func doWork(id int, w worker) { for n := range w.in { fmt.Printf(\"@%d---%d\\n\", id, n) // 通知外面 做完了( channel 是一等公民) w.done() } } type worker struct { in chan int done func() } // 告诉外面用的人 , 我这个channel怎么用 func createWorker(id int, wg *sync.WaitGroup) worker { // 告诉外面用的人 , 我这个channel怎么用 // w := worker{ in: make(chan int), // 函数式编程 // 匿名函数来赋值 done: func() { wg.Done() }, } go doWork(id, w) return w } func chanDemo() { var wg sync.WaitGroup var workers [10]worker for i := 0; i 6-3 使用Channel进行树的遍历 code01 package tree import \"fmt\" type Node struct { Value int Left, Right *Node } func (node Node) Print() { fmt.Print(node.Value, \" \") } func (node *Node) SetValue(value int) { if node == nil { fmt.Println(\"Setting Value to nil \" + \"node. Ignored.\") return } node.Value = value } func CreateNode(value int) *Node { return &Node{Value: value} } package tree import \"fmt\" func (node *Node) Traverse() { node.TraverseFunc(func(n *Node) { n.Print() }) fmt.Println() } func (node *Node) TraverseFunc(f func(*Node)) { if node == nil { return } node.Left.TraverseFunc(f) f(node) node.Right.TraverseFunc(f) } func (node *Node) TraverseWithChannel() chan *Node { out := make(chan *Node) go func() { node.TraverseFunc(func(node *Node) { out 6-4 Select 使用select 进行调度 code1 非阻塞式的处理 package main import \"fmt\" func main() { var c1, c2 chan int select { case n := code02 死循环 func main() { var c1, c2 chan int for { select { case n := code03 改进 package main import ( \"fmt\" \"math/rand\" \"time\" ) func generator() chan int { out := make(chan int) go func() { i := 0 for { time.Sleep( time.Duration(rand.Intn(1500)) * time.Millisecond, ) out code04 temp 改进中 package main import ( \"fmt\" \"math/rand\" \"time\" ) func generator() chan int { out := make(chan int) go func() { i := 0 for { time.Sleep( time.Duration(rand.Intn(1500)) * time.Millisecond, ) out code05 sleep长一点就会出问题 package main import ( \"fmt\" \"math/rand\" \"time\" ) func generator() chan int { out := make(chan int) go func() { i := 0 for { time.Sleep( time.Duration(rand.Intn(1500)) * time.Millisecond, ) out 新的数据会把之前的数据冲掉 code06 吧收到的n,存下来排队 package main import ( \"fmt\" \"math/rand\" \"time\" ) func generator() chan int { out := make(chan int) go func() { i := 0 for { time.Sleep( time.Duration(rand.Intn(1500)) * time.Millisecond, ) out 0 { activeWorker = work activeValue = values[0] } select { case n = code07 让程序 10秒钟后结束 package main import ( \"fmt\" \"math/rand\" \"time\" ) func generator() chan int { out := make(chan int) go func() { i := 0 for { time.Sleep( time.Duration(rand.Intn(1500)) * time.Millisecond, ) out 0 { activeWorker = work activeValue = values[0] } select { case n = code08 超时的情况 package main import ( \"fmt\" \"math/rand\" \"time\" ) func generator() chan int { out := make(chan int) go func() { i := 0 for { time.Sleep( time.Duration(rand.Intn(1500)) * time.Millisecond, ) out 0 { activeWorker = work activeValue = values[0] } select { case n = code09 定时的加入 每秒显示长度 package main import ( \"fmt\" \"math/rand\" \"time\" ) func generator() chan int { out := make(chan int) go func() { i := 0 for { time.Sleep( time.Duration(rand.Intn(1500)) * time.Millisecond, ) out 0 { activeWorker = work activeValue = values[0] } select { case n = 6-5 传统同步机制 传统同步机制 WaitGroup Mutex Cond code0 init atomic package main import ( \"fmt\" \"time\" ) type atomicInt int func (a *atomicInt) increment() { *a++ } func (a *atomicInt) get() int { return int(*a) } func main() { var a atomicInt a.increment() go func() { a.increment() }() time.Sleep(time.Millisecond) fmt.Println(a) } /** 2 Process finished with the exit code 0 */ PS E:\\Projects\\GolandProjects\\go-camp\\mooc\\code\\learngo\\basic\\atomic> go run -race .\\atomic.go ================== WARNING: DATA RACE Read at 0x00c00000e0d8 by main goroutine: main.main() E:/Projects/GolandProjects/go-camp/mooc/code/learngo/basic/atomic/atomic.go:24 +0xee Previous write at 0x00c00000e0d8 by goroutine 7: main.(*atomicInt).increment() E:/Projects/GolandProjects/go-camp/mooc/code/learngo/basic/atomic/atomic.go:11 +0x45 main.main.func1() E:/Projects/GolandProjects/go-camp/mooc/code/learngo/basic/atomic/atomic.go:21 +0x2e Goroutine 7 (finished) created at: main.main() data race 存在 code01 加上锁的 package main import ( \"fmt\" \"sync\" \"time\" ) type atomicInt struct { value int lock sync.Mutex } func (a *atomicInt) increment() { a.lock.Lock() defer a.lock.Unlock() a.value++ } func (a *atomicInt) get() int { a.lock.Lock() defer a.lock.Unlock() return a.value } func main() { var a atomicInt a.increment() go func() { a.increment() }() time.Sleep(time.Millisecond) fmt.Println(a.get()) } /** 2 Process finished with the exit code 0 */ PS E:\\Projects\\GolandProjects\\go-camp\\mooc\\code\\learngo\\basic\\atomic> go run -race .\\atomic.go 2 PS E:\\Projects\\GolandProjects\\go-camp\\mooc\\code\\learngo\\basic\\atomic> 这回没有data race了 code 02 部分加锁 (匿名函数) func (a *atomicInt) increment() { fmt.Println(\"safe increment\") func() { a.lock.Lock() defer a.lock.Unlock() a.value++ }() } safe increment safe increment 2 Process finished with the exit code 0 协程Coroutine 轻量级“线程” 非抢占式多任务处理，由协程主动交出控制权 编译器/解释器/虚拟机层面的多任务 多个协程可能在一个或多个线程上运行 这可能是最容易理解的 Go Mutex 源码剖析 6-6 并发模式（上） code00 init package main import ( \"fmt\" \"math/rand\" \"time\" ) // chan 是一等公民 func msgGen() chan string { c := make(chan string) go func() { i := 0 for { time.Sleep(time.Millisecond * time.Duration(rand.Intn(2000))) // sprintf 作为字符串打印 c code01 加上方向 package main import ( \"fmt\" \"math/rand\" \"time\" ) // chan 是一等公民 func msgGen() code 02 开两个 msgGen package main import ( \"fmt\" \"math/rand\" \"time\" ) // chan 是一等公民 func msgGen() code03 加上参数 package main import ( \"fmt\" \"math/rand\" \"time\" ) // chan 是一等公民 func msgGen(name string) 上面是交替的等待,显然是不对的 code 04 让他们交替 package main import ( \"fmt\" \"math/rand\" \"time\" ) // chan 是一等公民 func msgGen(name string) code 05 select 方式 func fanInBySelect(c1, c2 比较 非select 和 select 6-7 并发模式（下） code00 出现问题 goroutine循环变量的坑 package main import ( \"fmt\" \"math/rand\" \"time\" ) // chan 是一等公民 func msgGen(name string) go语言forin循环的一个bug,导致只能拿到最后一次的 go 开routine 的时候不会拿值,等到 调用的时候才会拿值 code01 解决方式self 使用temp func fanIn(chs ... 或者这样 func fanIn(chs ... 终极解决,因为go语言全是值传递 所以 func fanIn(chs ... 6-8 并发任务的控制 code00 select 等待 (非阻塞等待) func nonBlockingWait(c code01 timeout 支持设置等待时间(超时机制) func timeoutWait(c 当 等待时间小于任务间隔时间 ,可能会出现 等待 (走到else {no message from serve\")分支 func timeoutWait(c code02 处理中断 package main import ( \"fmt\" \"math/rand\" \"time\" ) // chan 是一等公民 func msgGen(name string) 考虑时间场景中: 我的等待代码部分,是正在做事情,而我不希望 异常中断 准备做成: 能够通知我 退出 信号 // chan bool 或者 chan struct{} // 这个 chan struct{} 里面没有任何的数据,他比bool更加的省空间 func msgGen(name string, done chan struct{}) 主函数 func main() { done :=make(chan struct{}) // 生成消息 m1 := msgGen(\"服务A\",done) m2 := msgGen(\"服务B\",done) for i := 0; i 大部分的chan都是单向的 这个done可以做成双向的,可以在清理完后,再通知主函数可以正常退出了 code03 优雅的退出 服务器的优雅退出 package main import ( \"fmt\" \"math/rand\" \"time\" ) // chan bool 或者 chan struct{} // 这个 chan struct{} 里面没有任何的数据,他比bool更加的省空间 func msgGen(name string, done chan struct{}) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 09:44:25 "},"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第7章_迷宫的广度优先搜索/":{"url":"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第7章_迷宫的广度优先搜索/","title":"第7章_迷宫的广度优先搜索","keywords":"","body":"7-1 迷宫_算法7-2 迷宫代码实现7-1 迷宫_算法 7-2 迷宫代码实现 6 5 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 1 1 1 0 0 0 1 0 0 1 0 1 0 0 0 package main import ( \"fmt\" \"os\" ) func readMaze(filename string) [][]int { file, err := os.Open(filename) if err != nil { panic(err) } var row, col int fmt.Fscanf(file, \"%d %d\", &row, &col) maze := make([][]int, row) for i := range maze { maze[i] = make([]int, col) for j := range maze[i] { fmt.Fscanf(file, \"%d\", &maze[i][j]) } } return maze } type point struct { i, j int } var dirs = [4]point{ {-1, 0}, {0, -1}, {1, 0}, {0, 1}} func (p point) add(r point) point { return point{p.i + r.i, p.j + r.j} } func (p point) at(grid [][]int) (int, bool) { if p.i = len(grid) { return 0, false } if p.j = len(grid[p.i]) { return 0, false } return grid[p.i][p.j], true } func walk(maze [][]int, start, end point) [][]int { steps := make([][]int, len(maze)) for i := range steps { steps[i] = make([]int, len(maze[i])) } Q := []point{start} for len(Q) > 0 { cur := Q[0] Q = Q[1:] if cur == end { break } for _, dir := range dirs { next := cur.add(dir) val, ok := next.at(maze) if !ok || val == 1 { continue } val, ok = next.at(steps) if !ok || val != 0 { continue } if next == start { continue } curSteps, _ := cur.at(steps) steps[next.i][next.j] = curSteps + 1 Q = append(Q, next) } } return steps } func main() { maze := readMaze(\"lang/maze/maze.in\") steps := walk(maze, point{0, 0}, point{len(maze) - 1, len(maze[0]) - 1}) for _, row := range steps { for _, val := range row { fmt.Printf(\"%3d\", val) } fmt.Println() } // TODO: construct path from steps } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 09:44:25 "},"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第8章_http及其他标准库/":{"url":"阶段一_Go语言基础入门和编程思维/02_Go语言编程思想/第8章_http及其他标准库/","title":"第8章_http及其他标准库","keywords":"","body":"第8章_http及其他标准库8-1 http标准库8-2 json数据格式的处理+v格式化打印使用 json库 格式化库json字段省略空字段json 嵌套指针也可以切片也支持8-3 第三方API数据格式的解析技巧map类型收 json结构体收json8-4 gin框架介绍8-5 为gin增加middlewarecode 01 initcode 02 加中间件拦截code03 requestId生成TODO For Blog第8章_http及其他标准库 8-1 http标准库 package main import ( \"fmt\" \"net/http\" \"net/http/httputil\" ) func main() { resp, err := http.Get(\"http://www.imooc.com\") if err != nil { panic(err) } defer resp.Body.Close() response, err := httputil.DumpResponse(resp, true) if err != nil { panic(err) } fmt.Printf(\"%s\\n\", response) } 我现在想对 httpclinet进行控制 比如我想要访问手机版的imooc package main import ( \"fmt\" \"net/http\" \"net/http/httputil\" ) func main() { request, err := http.NewRequest( http.MethodGet, \"http://www.imooc.com\", nil, ) request.Header.Add(\"User-Agent\",\"Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1\") resp, err := http.DefaultClient.Do(request) if err != nil { panic(err) } defer resp.Body.Close() response, err := httputil.DumpResponse(resp, true) if err != nil { panic(err) } fmt.Printf(\"%s\\n\", response) } 8-2 json数据格式的处理 +v格式化打印 package main import \"fmt\" type Order struct { Id string Name string Quantity int TotalPrice int } func main() { o:=Order{ Id: \"124\", Name: \"lreag go\", Quantity: 3, TotalPrice: 30, } fmt.Printf(\"%+v\",o) } 使用 json库 格式化库 package main import ( \"encoding/json\" \"fmt\" ) type Order struct { Id string Name string Quantity int TotalPrice int } func main() { o:=Order{ Id: \"124\", Name: \"lreag go\", Quantity: 3, TotalPrice: 30, } //fmt.Printf(\"%+v\",o) b,err:=json.Marshal(o) if err != nil { panic(err) } fmt.Printf(\"%s\\n\",b) } json字段 package main import ( \"encoding/json\" \"fmt\" ) type Order struct { Id string `json:\"id\"` Name string `json:\"name\"` Quantity int `json:\"quantity\"` TotalPrice int`json:\"total_price\"` } func main() { o:=Order{ Id: \"124\", Name: \"lreag go\", Quantity: 3, TotalPrice: 30, } //fmt.Printf(\"%+v\",o) b,err:=json.Marshal(o) if err != nil { panic(err) } fmt.Printf(\"%s\\n\",b) } 在结构体里面,首字母小写的字段是不能被看到的 省略空字段 package main import ( \"encoding/json\" \"fmt\" ) type Order struct { Id string `json:\"id\"` Name string `json:\"name,omitempty\"` Quantity int `json:\"quantity\"` TotalPrice int `json:\"total_price\"` } func main() { o := Order{ Id: \"124\", //Name: \"lreag go\", Quantity: 3, TotalPrice: 30, } //fmt.Printf(\"%+v\",o) b, err := json.Marshal(o) if err != nil { panic(err) } fmt.Printf(\"%s\\n\", b) } /** {\"id\":\"124\",\"quantity\":3,\"total_price\":30} Process finished with the exit code 0 */ json 嵌套 package main import ( \"encoding/json\" \"fmt\" ) type OrderItem struct { ID string `json:\"id\"` Name string `json:\"name\"` Price float64 `json:\"price\"` } type Order struct { Id string `json:\"id\"` Item OrderItem `json:\"item\"` Quantity int `json:\"quantity\"` TotalPrice int `json:\"total_price\"` } func main() { o := Order{ Id: \"124\", Item: OrderItem{ ID: \"8675645\", Name: \"nancy\", Price: 0, }, Quantity: 3, TotalPrice: 30, } //fmt.Printf(\"%+v\",o) b, err := json.Marshal(o) if err != nil { panic(err) } fmt.Printf(\"%s\\n\", b) } /** { \"id\": \"124\", \"item\": { \"id\": \"8675645\", \"name\": \"nancy\", \"price\": 0 }, \"quantity\": 3, \"total_price\": 30 } */ 指针也可以 package main import ( \"encoding/json\" \"fmt\" ) type OrderItem struct { ID string `json:\"id\"` Name string `json:\"name\"` Price float64 `json:\"price\"` } type Order struct { Id string `json:\"id\"` Item *OrderItem `json:\"item\"` Quantity int `json:\"quantity\"` TotalPrice int `json:\"total_price\"` } func main() { o := Order{ Id: \"124\", Item: &OrderItem{ ID: \"8675645\", Name: \"nancy\", Price: 0, }, Quantity: 3, TotalPrice: 30, } //fmt.Printf(\"%+v\",o) b, err := json.Marshal(o) if err != nil { panic(err) } fmt.Printf(\"%s\\n\", b) } /** { \"id\": \"124\", \"item\": { \"id\": \"8675645\", \"name\": \"nancy\", \"price\": 0 }, \"quantity\": 3, \"total_price\": 30 } */ 切片也支持 package main import ( \"encoding/json\" \"fmt\" ) type OrderItem struct { ID string `json:\"id\"` Name string `json:\"name\"` Price float64 `json:\"price\"` } type Order struct { Id string `json:\"id\"` Item *[]OrderItem `json:\"item\"` Quantity int `json:\"quantity\"` TotalPrice int `json:\"total_price\"` } func main() { o := Order{ Id: \"124\", Item: &[]OrderItem{ { ID: \"8675645\", Name: \"nancy\", Price: 50, }, { ID: \"2456733\", Name: \"yael\", Price: 20, }, }, Quantity: 3, TotalPrice: 30, } //fmt.Printf(\"%+v\",o) b, err := json.Marshal(o) if err != nil { panic(err) } fmt.Printf(\"%s\\n\", b) } /** { \"id\": \"124\", \"item\": [ { \"id\": \"8675645\", \"name\": \"nancy\", \"price\": 50 }, { \"id\": \"2456733\", \"name\": \"yael\", \"price\": 20 } ], \"quantity\": 3, \"total_price\": 30 } */ 8-3 第三方API数据格式的解析技巧 map类型收 json package main import ( \"encoding/json\" \"fmt\" ) type OrderItem struct { ID string `json:\"id\"` Name string `json:\"name\"` Price float64 `json:\"price\"` } type Order struct { Id string `json:\"id\"` Item []*OrderItem `json:\"item\"` Quantity int `json:\"quantity\"` TotalPrice int `json:\"total_price\"` } func marshal() { o := Order{ Id: \"124\", Item: []*OrderItem{ { ID: \"8675645\", Name: \"nancy\", Price: 50, }, { ID: \"2456733\", Name: \"yael\", Price: 20, }, }, Quantity: 3, TotalPrice: 30, } fmt.Println(o) } func unmarshal() { s := `{\"id\":\"124\",\"item\":[{\"id\":\"8675645\",\"name\":\"nancy\",\"price\":50},{\"id\":\"2456733\",\"name\":\"yael\",\"price\":20}],\"quantity\":3,\"total_price\":30} ` var o Order json.Unmarshal([]byte(s), &o) fmt.Printf(\"%+v\", o) } func parseNLP() { res := `{ \"data\": [ { \"synonym\":\"\", \"weight\":\"0.6\", \"word\": \"真丝\", \"tag\":\"材质\" }, { \"synonym\":\"\", \"weight\":\"0.8\", \"word\": \"韩都衣舍\", \"tag\":\"品牌\" }, { \"synonym\":\"连身裙;联衣裙\", \"weight\":\"1.0\", \"word\": \"连衣裙\", \"tag\":\"品类\" } ] }` //m := struct { // Data []struct { // Synonym string `json:\"synonym\"` // Tag string `json:\"tag\"` // } `json:\"data\"` //}{} m := make(map[string]interface{}) err := json.Unmarshal([]byte(res), &m) if err != nil { panic(err) } fmt.Printf(\"-----------------------------------------------------------\\n\") fmt.Printf(\"%+v\\n\",m[\"data\"].([]interface{})[2].(map[string]interface{})[\"synonym\"]) fmt.Printf(\"-----------------------------------------------------------\\n\") for k,v := range m{ fmt.Println(k,v) for _,v2 := range v.([]interface{}){ for v3,v4:=range v2.(map[string]interface{}){ fmt.Printf(\"v3:%v---v4:%v\\n\",v3,v4) } //fmt.Printf(\"v1:%v---v2%v\\n\",v1,v2) } } fmt.Printf(\"%+v\\n\", m) //fmt.Printf(\"%+v, %+v\\n\", m.Data[2].Synonym, m.Data[2].Tag) } func main() { parseNLP() } 其中的map[string]interface 属实复杂 fmt.Printf(\"%+v\\n\", m[\"data\"].([]interface{})[2].(map[string]interface{})[\"synonym\"], ) 结构体收json 换成结构体的 m := struct { Data []struct { Synonym string `json:\"synonym\"` Tag string `json:\"tag\"` } `json:\"data\"` }{} err := json.Unmarshal([]byte(res), &m) if err != nil { panic(err) } fmt.Printf(\"%+v, %+v\\n\", m.Data[2].Synonym, m.Data[2].Tag) 8-4 gin框架介绍 8-5 为gin增加middleware gin- code 01 init package main import \"github.com/gin-gonic/gin\" func main() { r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"pong\", }) }) r.Run() // listen and serve on 0.0.0.0:8080 } code 02 加中间件拦截 package main import ( \"github.com/gin-gonic/gin\" \"go.uber.org/zap\" \"time\" ) func main() { r := gin.Default() logger, err := zap.NewProduction() if err != nil { panic(err) } // middleware r.Use(func(c *gin.Context) { s := time.Now() c.Next() // 不管访问什么,都能先进到这里面来 // log latency, response code logger.Info(\"incoming request:\", zap.String(\"path\", c.Request.URL.Path), zap.Int(\"status\", c.Writer.Status()), zap.Duration(\"elapsed\", time.Now().Sub(s)), ) //log.Fatalf(c.Request.URL.Path) }) r.GET(\"/ping\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"pong\", }) }) r.GET(\"/hello\", func(c *gin.Context) { c.String(200, \"hello gin\") }) r.Run() // listen and serve on 0.0.0.0:8080 } code03 requestId生成 package main import ( \"github.com/gin-gonic/gin\" \"go.uber.org/zap\" \"math/rand\" \"time\" ) func main() { r := gin.Default() logger, err := zap.NewProduction() if err != nil { panic(err) } // middleware r.Use(func(c *gin.Context) { s := time.Now() c.Next() // 不管访问什么,都能先进到这里面来 // log latency, response code logger.Info(\"incoming request:\", zap.String(\"path\", c.Request.URL.Path), zap.Int(\"status\", c.Writer.Status()), zap.Duration(\"elapsed\", time.Now().Sub(s)), ) //log.Fatalf(c.Request.URL.Path) }, func(c *gin.Context) { c.Set(\"requestId\", rand.Int()) c.Next() }) r.GET(\"/ping\", func(c *gin.Context) { h := gin.H{ \"message\": \"pong\", } if rid, exists := c.Get(\"requestId\"); exists { h[\"requestId\"] = rid } c.JSON(200, h) }) r.GET(\"/hello\", func(c *gin.Context) { c.String(200, \"hello gin\") }) r.Run() // listen and serve on 0.0.0.0:8080 } gin-gonic/gin middleware的使用 context的使用 TODO For Blog 写一个脚本实现gitee page 自动更新 github page 自动同步 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 15:10:29 "},"阶段三_租辆酷车_共享出行产品设计与研发/03_租辆酷车后端_接入微服务GRPC/第2章_初识微服务框架gRPC与protobuf/":{"url":"阶段三_租辆酷车_共享出行产品设计与研发/03_租辆酷车后端_接入微服务GRPC/第2章_初识微服务框架gRPC与protobuf/","title":"第2章_初识微服务框架gRPC与protobuf","keywords":"","body":" Protocol Buffer trip.proto 文件: syntax = \"proto3\"; package coolcar; option go_package=\"server/proto/gen/go;trippb\"; message Trip{ string start = 1; // 第一个字段是 start string end = 2; // 第二个字段是 end int64 duration_sec = 3; // duration in second int64 fee_cent = 4; } protoc -I=. --go_out=path=source_relative:gen/go protoc -I=E:\\Projects\\GolandProjects\\go-camp\\mooc\\code\\coolcar\\server\\proto --go_out=paths=source_relative:gen/go trip.proto 终于生成出来了 // Code generated by protoc-gen-go. DO NOT EDIT. // versions: // protoc-gen-go v1.27.1 // protoc v3.13.0 // source: trip.proto package trippb import ( protoreflect \"google.golang.org/protobuf/reflect/protoreflect\" protoimpl \"google.golang.org/protobuf/runtime/protoimpl\" reflect \"reflect\" sync \"sync\" ) const ( // Verify that this generated code is sufficiently up-to-date. _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion) // Verify that runtime/protoimpl is sufficiently up-to-date. _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20) ) type Trip struct { // 小写的不用管它 state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields // go 会自动把 _ 分隔 转成 驼峰吗命名 Start string `protobuf:\"bytes,1,opt,name=start,proto3\" json:\"start,omitempty\"` // 第一个字段是 start End string `protobuf:\"bytes,2,opt,name=end,proto3\" json:\"end,omitempty\"` // 第二个字段是 end DurationSec int64 `protobuf:\"varint,3,opt,name=duration_sec,json=durationSec,proto3\" json:\"duration_sec,omitempty\"` // duration in second FeeCent int64 `protobuf:\"varint,4,opt,name=fee_cent,json=feeCent,proto3\" json:\"fee_cent,omitempty\"` } func (x *Trip) Reset() { *x = Trip{} if protoimpl.UnsafeEnabled { mi := &file_trip_proto_msgTypes[0] ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) ms.StoreMessageInfo(mi) } } func (x *Trip) String() string { return protoimpl.X.MessageStringOf(x) } func (*Trip) ProtoMessage() {} func (x *Trip) ProtoReflect() protoreflect.Message { mi := &file_trip_proto_msgTypes[0] if protoimpl.UnsafeEnabled && x != nil { ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) if ms.LoadMessageInfo() == nil { ms.StoreMessageInfo(mi) } return ms } return mi.MessageOf(x) } // Deprecated: Use Trip.ProtoReflect.Descriptor instead. func (*Trip) Descriptor() ([]byte, []int) { return file_trip_proto_rawDescGZIP(), []int{0} } func (x *Trip) GetStart() string { if x != nil { return x.Start } return \"\" } func (x *Trip) GetEnd() string { if x != nil { return x.End } return \"\" } func (x *Trip) GetDurationSec() int64 { if x != nil { return x.DurationSec } return 0 } func (x *Trip) GetFeeCent() int64 { if x != nil { return x.FeeCent } return 0 } var File_trip_proto protoreflect.FileDescriptor var file_trip_proto_rawDesc = []byte{ 0x0a, 0x0a, 0x74, 0x72, 0x69, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x63, 0x6f, 0x6f, 0x6c, 0x63, 0x61, 0x72, 0x22, 0x6c, 0x0a, 0x04, 0x54, 0x72, 0x69, 0x70, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x65, 0x6e, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x65, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x63, 0x12, 0x19, 0x0a, 0x08, 0x66, 0x65, 0x65, 0x5f, 0x63, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x66, 0x65, 0x65, 0x43, 0x65, 0x6e, 0x74, 0x42, 0x1c, 0x5a, 0x1a, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x3b, 0x74, 0x72, 0x69, 0x70, 0x70, 0x62, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33, } var ( file_trip_proto_rawDescOnce sync.Once file_trip_proto_rawDescData = file_trip_proto_rawDesc ) func file_trip_proto_rawDescGZIP() []byte { file_trip_proto_rawDescOnce.Do(func() { file_trip_proto_rawDescData = protoimpl.X.CompressGZIP(file_trip_proto_rawDescData) }) return file_trip_proto_rawDescData } var file_trip_proto_msgTypes = make([]protoimpl.MessageInfo, 1) var file_trip_proto_goTypes = []interface{}{ (*Trip)(nil), // 0: coolcar.Trip } var file_trip_proto_depIdxs = []int32{ 0, // [0:0] is the sub-list for method output_type 0, // [0:0] is the sub-list for method input_type 0, // [0:0] is the sub-list for extension type_name 0, // [0:0] is the sub-list for extension extendee 0, // [0:0] is the sub-list for field type_name } func init() { file_trip_proto_init() } func file_trip_proto_init() { if File_trip_proto != nil { return } if !protoimpl.UnsafeEnabled { file_trip_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} { switch v := v.(*Trip); i { case 0: return &v.state case 1: return &v.sizeCache case 2: return &v.unknownFields default: return nil } } } type x struct{} out := protoimpl.TypeBuilder{ File: protoimpl.DescBuilder{ GoPackagePath: reflect.TypeOf(x{}).PkgPath(), RawDescriptor: file_trip_proto_rawDesc, NumEnums: 0, NumMessages: 1, NumExtensions: 0, NumServices: 0, }, GoTypes: file_trip_proto_goTypes, DependencyIndexes: file_trip_proto_depIdxs, MessageInfos: file_trip_proto_msgTypes, }.Build() File_trip_proto = out.File file_trip_proto_rawDesc = nil file_trip_proto_goTypes = nil file_trip_proto_depIdxs = nil } protobuf 的所有字段 都是可选的 go中的零值 omit empty 动态增加字段,新老系统同时可用 默认字段不填,填的是零值 grpc protoc -I=E:\\Projects\\GolandProjects\\go-camp\\mooc\\code\\coolcar\\server\\proto --go_out=plugins=grpc,paths=source_relative:gen/go trip.proto server package main import ( trippb \"coolcar/proto/gen/go\" trip \"coolcar/tripservice\" \"google.golang.org/grpc\" \"log\" \"net\" ) func main() { lis, err := net.Listen(\"tcp\", \":8081\") if err != nil { log.Fatalf(\"failed to listen: %v\", err) } s := grpc.NewServer() trippb.RegisterTripServiceServer(s, &trip.Service{}) log.Fatal(s.Serve(lis)) } client package main import ( \"context\" trippb \"coolcar/proto/gen/go\" \"fmt\" \"google.golang.org/grpc\" \"log\" ) func main() { log.SetFlags(log.Lshortfile) conn, err := grpc.Dial(\"localhost:8081\",grpc.WithInsecure()) if err != nil { log.Fatalf(\"cannot connect server: %v\", err) } tsClient := trippb.NewTripServiceClient(conn) r, err := tsClient.GetTrip(context.Background(), &trippb.GetTripRequest{ Id: \"tr35653\", }) if err != nil { log.Fatalf(\"can not call GetTrip : %v\", err) } fmt.Println(r) } /** id:\"tr35653\" trip:{start:\"abc\" start_pos:{latitude:30 longitude:120} end_pos:{latitude:30 longitude:120} path_locaitons:{latitude:31 longitude:118} path_locaitons:{latitude:37 longitude:125} status:IN_PROGRESS end:\"def\" duration_sec:36000 fee_cent:13000} Process finished with the exit code 0 */ new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 23:50:00 "}}